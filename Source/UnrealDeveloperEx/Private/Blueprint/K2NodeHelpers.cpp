#include "Blueprint/K2NodeHelpers.h"

#include "EdGraph/EdGraphNode.h"
#include "Kismet2/BlueprintEditorUtils.h"
#include "Kismet/GameplayStatics.h"
#include "Kismet/KismetSystemLibrary.h"
#include "Misc/EngineVersionComparison.h"
#include "Engine/Engine.h"
#include "EdGraphSchema_K2.h"

#include "UnrealDeveloperEx.final.h"

#define LOCTEXT_NAMESPACE "UnrealDeveloperEx"


bool FK2NodeHelpers::CreateInputPins(UEdGraphNode* Node, UFunction* Function)
{
	auto K2Schema = GetDefault<UEdGraphSchema_K2>();
	bool bAllPinsGood = true;

#if UE_VERSION_NEWER_THAN(4, 19, -1)
	TSet<FName> PinsToHide;
#else
	TSet<FString> PinsToHide;
#endif
	FBlueprintEditorUtils::GetHiddenPinsForFunction(Node->GetGraph(), Function, PinsToHide);
	for (TFieldIterator<FProperty> PropIt(Function); PropIt && (PropIt->PropertyFlags & CPF_Parm); ++PropIt)
	{
		auto Param = *PropIt;
		const bool bIsFunctionInput = !Param->HasAnyPropertyFlags(CPF_OutParm) || Param->HasAnyPropertyFlags(CPF_ReferenceParm);
		if (!bIsFunctionInput)
		{
			// skip function output, it's internal node data
			continue;
		}

		const bool bIsRefParam = Param->HasAnyPropertyFlags(CPF_ReferenceParm) && bIsFunctionInput;
#if UE_VERSION_NEWER_THAN(4, 19, -1)
		UEdGraphNode::FCreatePinParams PinParams;
		PinParams.bIsReference = bIsRefParam;
		UEdGraphPin* Pin = Node->CreatePin(EGPD_Input, FName(), FName(), nullptr, Param->GetFName(), PinParams);
#else
		UEdGraphPin* Pin = Node->CreatePin(EGPD_Input, FString(), FString(), nullptr, Param->GetName(), EPinContainerType::None, bIsRefParam);
#endif
		const bool bPinGood = (Pin != NULL) && K2Schema->ConvertPropertyToPinType(Param, /*out*/ Pin->PinType);

		if (bPinGood)
		{
			//Flag pin as read only for const reference property
			Pin->bDefaultValueIsIgnored = Param->HasAllPropertyFlags(CPF_ConstParm | CPF_ReferenceParm) && (!Function->HasMetaData(FBlueprintMetadata::MD_AutoCreateRefTerm) || Pin->PinType.IsContainer());

			const bool bAdvancedPin = Param->HasAllPropertyFlags(CPF_AdvancedDisplay);
			Pin->bAdvancedView = bAdvancedPin;
			if (bAdvancedPin && (ENodeAdvancedPins::NoPins == Node->AdvancedPinDisplay))
			{
				Node->AdvancedPinDisplay = ENodeAdvancedPins::Hidden;
			}

			FString ParamValue;
			if (K2Schema->FindFunctionParameterDefaultValue(Function, Param, ParamValue))
			{
				K2Schema->SetPinAutogeneratedDefaultValue(Pin, ParamValue);
			}
			else
			{
				K2Schema->SetPinAutogeneratedDefaultValueBasedOnType(Pin);
			}

			if (PinsToHide.Contains(Pin->PinName))
			{
				Pin->bHidden = true;
			}
		}

		bAllPinsGood &= bPinGood;
	}

	return bAllPinsGood;
}

void FK2NodeHelpers::CreateOutputPins(UEdGraphNode* Node, FMulticastDelegateProperty* Property, FName PropertyName)
{
	UEdGraphPin* ExecPin;
	TArray<UEdGraphPin*> ParameterPins;
	CreateOutputPins(Node, Property, ExecPin, ParameterPins, PropertyName);
}

void FK2NodeHelpers::CreateOutputPins(UEdGraphNode* Node, FMulticastDelegateProperty* Property, UEdGraphPin*& ExecPin, TArray<UEdGraphPin*>& ParameterPins, FName PropertyName)
{
	auto Schema = GetDefault<UEdGraphSchema_K2>();

#if UE_VERSION_NEWER_THAN(4, 19, -1)
	ExecPin = Node->CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, IsValid(PropertyName) ? PropertyName : Property->GetFName());
#else
	ExecPin = Node->CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Exec, IsValid(PropertyName) ? PropertyName : *Property->GetName());
#endif

	// HACK: Store Delegate here to later Find it in FindDelegatePins
	//ExecPin->DefaultObject = Property->SignatureFunction;
	ExecPin->PinToolTip = Property->GetName();

	if (auto DelegateSignatureFunction = Valid(Property->SignatureFunction))
	{
		for (TFieldIterator<FProperty> PropIt(DelegateSignatureFunction); PropIt && (PropIt->PropertyFlags & CPF_Parm); ++PropIt)
		{
			auto* Param = *PropIt;
			const bool bIsFunctionInput = !Param->HasAnyPropertyFlags(CPF_OutParm) || Param->HasAnyPropertyFlags(CPF_ReferenceParm);
			if (bIsFunctionInput)
			{
#if UE_VERSION_NEWER_THAN(4, 19, -1)
				UEdGraphPin* Pin = Node->CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Wildcard, Param->GetFName());
#else
				UEdGraphPin* Pin = Node->CreatePin(EGPD_Output, UEdGraphSchema_K2::PC_Wildcard, Param->GetName());
#endif
				Schema->ConvertPropertyToPinType(Param, /*out*/ Pin->PinType);

				// HACK: Store Delegate here to later Find it in FindDelegatePins
				Pin->PinToolTip = Property->GetName();

				ParameterPins.Add(Pin);
			}
		}
	}
}

void FK2NodeHelpers::CreateOutputPins(UEdGraphNode* Node, UClass* Class)
{
	auto K2Schema = GetDefault<UEdGraphSchema_K2>();

	for (TFieldIterator<FProperty> PropertyIt(Class, EFieldIteratorFlags::IncludeSuper); PropertyIt; ++PropertyIt)
	{
		auto Property = *PropertyIt;

		//UClass* PropertyClass = CastChecked<UClass>(Property->GetOuter());
		const bool bIsDelegate = Property->IsA(FMulticastDelegateProperty::StaticClass());
		const bool bIsExposedToSpawn = UEdGraphSchema_K2::IsPropertyExposedOnSpawn(Property);
		const bool bIsSettableExternally = !Property->HasAnyPropertyFlags(CPF_DisableEditOnInstance);

		if (bIsExposedToSpawn &&
			!Property->HasAnyPropertyFlags(CPF_Parm) &&
			bIsSettableExternally &&
			Property->HasAllPropertyFlags(CPF_BlueprintVisible) &&
			!bIsDelegate)
		{
#if ENGINE_MAJOR_VERSION >= 4 && ENGINE_MINOR_VERSION >= 19 || ENGINE_MAJOR_VERSION >= 5
			UEdGraphPin* Pin = Node->CreatePin(EGPD_Input, FName(), FName(), nullptr, Property->GetFName());
#else
			UEdGraphPin* Pin = Node->CreatePin(EGPD_Input, FString(), FString(), nullptr, Property->GetName());
#endif
			const bool bPinGood = (Pin != nullptr) && K2Schema->ConvertPropertyToPinType(Property, /*out*/ Pin->PinType);

			// Copy tooltip from the property.
			if (Pin != nullptr)
			{
				K2Schema->ConstructBasicPinTooltip(*Pin, Property->GetToolTipText(), Pin->PinToolTip);
			}
		}
	}
}

FEdGraphPinType FK2NodeHelpers::GetWildcardPinType(UEdGraphPin* Pin, EPinContainerType PinContainerType)
{
	if (IsValid(Pin) && Pin->LinkedTo.Num() > 0)
	{
		if (IsValid(Pin->LinkedTo[0]))
			return Pin->LinkedTo[0]->PinType;
	}

	return MakePinType(UEdGraphSchema_K2::PC_Wildcard, PinContainerType);
}

FEdGraphPinType FK2NodeHelpers::GetWildcardPinObjectType(UEdGraphPin* Pin, UClass* ObjectClass, EPinContainerType PinContainerType)
{
	auto PinType = GetWildcardPinType(Pin, PinContainerType);
	if (PinType.PinCategory == UEdGraphSchema_K2::PC_Object
		|| PinType.PinCategory == UEdGraphSchema_K2::PC_Interface)
	{
		return PinType;
	}

	return MakePinType(UEdGraphSchema_K2::PC_Wildcard, ObjectClass, PinContainerType);
}

UClass* FK2NodeHelpers::GetPinTypeClass(UEdGraphPin* Pin, const FEdGraphPinType& PinType)
{
	if (auto SourceClass = Cast<UClass>(PinType.PinSubCategoryObject.Get()))
	{
		if (PinType.PinSubCategory == UEdGraphSchema_K2::PSC_Self)
		{
			if (auto K2Node = Cast<UK2Node>(Pin->GetOwningNode()))
			{
				return K2Node->GetBlueprint()->GeneratedClass;
			}
		}

		return SourceClass;
	}

	return nullptr;
}

UEdGraphNode* FK2NodeHelpers::GetLinkedPinNode(UEdGraphPin* Pin)
{
	if (IsValid(Pin) && Pin->LinkedTo.Num() > 0)
	{
		if (IsValid(Pin->LinkedTo[0]))
			return Pin->LinkedTo[0]->GetOwningNode();
	}

	return nullptr;
}
#if 0
void FK2NodeHelpers::ForEachOutputDelegate(UClass* ObjectClass, TFunction<void(FMulticastDelegateProperty*)> Predicate)
{
	for (TFieldIterator<FProperty> PropertyIt(ObjectClass); PropertyIt; ++PropertyIt)
	{
		if (auto AsMulticastDelegateProperty = Valid<FMulticastDelegateProperty>(*PropertyIt))
		{
			if (auto PropertyClass = AsMulticastDelegateProperty->GetOwnerClass())
			{
				// Expose only delegates declare in object implementing UStateInterface
				if (!PropertyClass->ImplementsInterface(UStateInterface::StaticClass()))
					continue;

				Predicate(AsMulticastDelegateProperty);
			}
		}
	}
}
#endif

FDelegateAndPins
FDelegateAndPins::FindDelegatePins(UEdGraphNode* Node, FMulticastDelegateProperty* Delegate)
{
	FDelegateAndPins Result{ Delegate };

	for (auto Pin : Node->Pins)
	{
		//if (Pin->DefaultObject != Delegate->SignatureFunction)
		if (Pin->PinToolTip != Delegate->GetName())
			continue;

		if (Pin->PinType.PinCategory == UEdGraphSchema_K2::PC_Exec)
			Result.ExecPin = Pin;
		else
			Result.ParameterPins.Add(Pin);
	}

	return Result;
}

#undef LOCTEXT_NAMESPACE
